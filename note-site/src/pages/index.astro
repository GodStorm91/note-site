---
import fs from 'node:fs';
import path from 'node:path';
import BaseLayout from '../layouts/BaseLayout.astro';

const notesDir = path.join(process.cwd(), 'src', 'content', 'notes');

type NoteMeta = { slug: string; title: string; category: string; mtime: number; excerpt: string };

function makeExcerpt(raw: string): string {
  // Remove image markdown and BearImages references
  let text = raw.replace(/!\[[^\]]*\]\([^)]*\)/g, '');
  text = text.replace(/!\([^)]*\)/g, '');
  // Collapse whitespace
  text = text.replace(/\s+/g, ' ').trim();
  if (text.length <= 160) return text;
  return text.slice(0, 160).trimEnd() + '…';
}

function collectNotes(dir: string, baseDir: string): NoteMeta[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const notes: NoteMeta[] = [];

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      notes.push(...collectNotes(fullPath, baseDir));
    } else if (entry.isFile() && (entry.name.endsWith('.md') || entry.name.endsWith('.mdx'))) {
      const relPath = path.relative(baseDir, fullPath);
      const relDir = path.dirname(relPath) === '.' ? '' : path.dirname(relPath);
      const slug = path.basename(entry.name).replace(/\.mdx?$/, '');

      // Derive title from first markdown H1 heading if available, so we
      // preserve original casing (including Vietnamese) from Bear.
      let title = slug
        .replace(/-/g, ' ')
        .replace(/\b\w/g, (c) => c.toUpperCase());
      let excerpt = '';
      try {
        const raw = fs.readFileSync(fullPath, 'utf8');
        const lines = raw.split(/\r?\n/);
        let seenTitle = false;
        const bodyLines: string[] = [];
        for (const line of lines) {
          const trimmed = line.trim();
          const m = trimmed.match(/^#\s+(.+)$/);
          if (m && !seenTitle) {
            title = m[1].trim();
            seenTitle = true;
            continue;
          }
          if (!trimmed) continue;
          if (trimmed.startsWith('#')) continue;
          if (trimmed.startsWith('![') || trimmed.startsWith('!(')) continue;
          bodyLines.push(trimmed);
        }
        if (bodyLines.length > 0) {
          excerpt = makeExcerpt(bodyLines.join(' '));
        }
      } catch (e) {
        console.warn('[notes] failed to read title/excerpt from', fullPath, e);
      }

      const stat = fs.statSync(fullPath);
      notes.push({ slug, title, category: relDir, mtime: stat.mtimeMs, excerpt });
    }
  }

  return notes;
}

console.log('[notes] notesDir =', notesDir);

let rawNotes: NoteMeta[] = [];
try {
  rawNotes = collectNotes(notesDir, notesDir);
  console.log('[notes] collected', rawNotes.length, 'files');
} catch (err) {
  console.error('[notes] collectNotes error:', err);
  rawNotes = [];
}

// De-duplicate by slug: if a note appears in multiple tag folders, pick the shortest category path
const bySlug = new Map<string, NoteMeta>();
for (const note of rawNotes) {
  const existing = bySlug.get(note.slug);
  if (!existing) {
    bySlug.set(note.slug, note);
  } else {
    const existingDepth = existing.category.split('/').filter(Boolean).length;
    const newDepth = note.category.split('/').filter(Boolean).length;
    // Prefer newer mtime; if equal, prefer shallower category
    if (note.mtime > existing.mtime || (note.mtime === existing.mtime && newDepth < existingDepth)) {
      bySlug.set(note.slug, note);
    }
  }
}

// Sort all notes by modified time desc for display order
const flatNotes = Array.from(bySlug.values()).sort((a, b) => b.mtime - a.mtime);

// Group by category path ("", "publish", "publish/project-x", ...)
const grouped = flatNotes.reduce((acc, note) => {
  const key = note.category || 'root';
  if (!acc[key]) acc[key] = [] as NoteMeta[];
  acc[key].push(note);
  return acc;
}, {} as Record<string, NoteMeta[]>);

// Collect popular tags
const tagCount = new Map<string, number>();
for (const note of flatNotes) {
  const fullPath = path.join(notesDir, `${note.slug}.md`);
  if (!fs.existsSync(fullPath)) continue;
  const raw = fs.readFileSync(fullPath, 'utf8');
  const matches = raw.match(/(^|\s)#([\p{L}\p{N}_/+-]+)/gu) || [];
  const tagsForNote = Array.from(
    new Set(
      matches
        .map((m) => m.replace(/^\s*#/, '').trim().toLowerCase())
        .filter((t) => t && !t.startsWith('publish'))
    )
  );
  for (const t of tagsForNote) {
    tagCount.set(t, (tagCount.get(t) || 0) + 1);
  }
}

const popularTags = Array.from(tagCount.entries())
  .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
  .slice(0, 6);

// Within each category, keep notes ordered by mtime desc
for (const key of Object.keys(grouped)) {
  grouped[key].sort((a, b) => b.mtime - a.mtime);
}

// Sort categories: root first, then alphabetically
const categories = Object.keys(grouped).sort((a, b) => {
  if (a === 'root') return -1;
  if (b === 'root') return 1;
  return a.localeCompare(b);
});

---

<BaseLayout title="Notes">
  <section class="card" style="box-shadow:none; border-radius:14px;">
    <div style="display:flex; justify-content:space-between; gap:1rem; align-items:center; margin-bottom:0.75rem;">
      <div>
        <h1 style="margin:0 0 0.25rem; font-size:1.6rem;">Notes</h1>
        <p class="muted" style="margin:0;">Mấy note public của mày (tag <code>#publish</code> trong Bear), auto build từ Markdown.</p>
      </div>
      <div>
        <input
          id="search-input"
          type="search"
          placeholder="Search notes..."
          style="padding:0.35rem 0.6rem; border-radius:999px; border:1px solid var(--border-subtle); font-size:0.9rem; min-width:180px;"
        />
      </div>
    </div>

    {popularTags.length > 0 && (
      <p class="muted" style="margin:0.25rem 0 0.5rem; font-size:0.85rem;">
        Popular tags:
        {popularTags.map(([tag, count]) => (
          <a
            href={`/tags/${encodeURIComponent(tag.toLowerCase().replace(/[\s/]+/g, '-'))}`}
            class="tag-pill"
          >
            #{tag}
            <span style="font-size:0.8em; opacity:0.7; margin-left:0.1rem;">({count})</span>
          </a>
        ))}
      </p>
    )}

    {flatNotes.length === 0 ? (
      <p style="margin-top:1rem;">Chưa có note nào sync từ Bear. Thử gắn tag <code>#publish</code> rồi chạy <code>npm run sync-bear</code>.</p>
    ) : (
      <div id="notes-list" style="margin-top:0.75rem;">
        {categories.map((cat) => (
          <section class="notes-section" data-category={cat}>
            <ul style="margin:0; padding-left:0; list-style:none;">
              {grouped[cat].map((note, idx) => (
                <li
                  class="note-item"
                  data-title={note.title.toLowerCase()}
                  data-category={note.category.toLowerCase()}
                  style="border-bottom:1px solid var(--border-subtle); padding:0.5rem 0;"
                >
                  <a href={`/notes/${note.slug}`} class="note-row" style="text-decoration:none;">
                    <div class="note-title">{note.title}</div>
                    {note.excerpt && (
                      <div class="note-excerpt">{note.excerpt}</div>
                    )}
                    <div class="note-meta">{new Date(note.mtime).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div>
                  </a>
                </li>
              ))}
            </ul>
          </section>
        ))}
      </div>
    )}
  </section>

  <script>
    const input = document.getElementById('search-input');
    const sections = Array.from(document.querySelectorAll('.notes-section'));

    input?.addEventListener('input', () => {
      const q = input.value.trim().toLowerCase();
      sections.forEach((section) => {
        const items = Array.from(section.querySelectorAll('.note-item'));
        let anyVisible = false;
        items.forEach((li) => {
          const title = li.getAttribute('data-title') || '';
          const cat = li.getAttribute('data-category') || '';
          const match = !q || title.includes(q) || cat.includes(q);
          (li as HTMLElement).style.display = match ? '' : 'none';
          if (match) anyVisible = true;
        });
        (section as HTMLElement).style.display = anyVisible ? '' : 'none';
      });
    });
  </script>
</BaseLayout>
